5.19 발표 대본

오늘은 스마트폰 데이터를 이용한 HAR System에서 

저번에 한석님이 발표하신 내용에서 보충된 내용과 제가 진행한 내용을 발표하겠습니다.

먼저 분석할 데이터가 어떻게 생성되었는지 알아보고 두번째로 데이터셋 구조와 

마지막으로 향후계획으로 발표를 마무리 하도록 하겠습니다.

실험은 19-48에서의 30명의 자원봉사자로 구성된 그룹에서 진행이 됩니다. 

스마트폰 센서를 부착하고 6가지 행동을 해서 센서에 기록된 데이터로 어떤 행동을 했는지 인식할 수 있는

모델을 만드는 것이 목표입니다.

그래서 이 문제는 종속변수가 6개인 다중 클래스 문제로 분류할 수 있습니다.

데이터는 다음의 사이트에서 다운받아 분석하였습니다.


다음은 실험 측정 방식입니다. 센서를 통해 가속도와 각속도를 50hz 주기로 측정하고 단위는 g로 측정됩니다.

왜 50hz 인가에 대해선 뒤에 설명하도록 하겠습니다.

실험은 2번 반복해서 이루어졌고, 다음 그림과 같이 왼쪽 허리에 스마트폰을 부착하여 진행한 실험과

자유로운 위치에 부착하여 이루어진 실험으로 2번의 실험이 이루어졌습니다.

그래서 여기 걷기 활동에 대해 측정된 가속도와 각속도 값을 보면 빨간색 x축이 중력가속도 값이 나오므로 중력의 방향이고

파란색 y축 각속도 값이 움직임에 따른 각속도 변화를 나타내므로 걷는 것을 생각해보면 몸쪽 방향이 y축임을 알 수 있습니다.

참고용 그림상에서는 z축을 나타내는 방향입니다.

이런식으로 각 6개 활동에 대한 x,y,z 3축의 가속도와 각속도를 측정하게 됩니다.


다음은 저번에 가속도와 자이로 센서에 대한 얘기가 짧게 소개되었었는데 거기서 조금 보충한 내용입니다.

기본적으로 스마트폰에 mems센서라는 것이 들어가는데 meme센서가 작동하는 원리가 그림에서 보다시피 스프링이 존재하고

움직임에 따라서 스프링이 변하게 되고 그 변위에 해당하는 값만큼 축전기의 plate 간격이 변하게 됩니다.

그래서 가속도는 이 capacitance 값의 변화로 검출됩니다.

각속도도 비슷하게 IMU라는 유닛에서 자이로스코프 센서를 통해 측정됩니다.

같은 mems센서고 그림과 같이 작은 무게를 가진 추가 회전하면 스프링의 변위가 발생하고 이 변위가 capacitance값을 변화시킵니다.

그리고 이 값 변화로 코리올리 힘을 계산할 수 있게 되고 계산된 코리올리 힘에서 각속도를 검출할 수 있습니다.



그 다음은 전처리 단계에 대해 알아보겠습니다. 앞에서 센서를 통해 측정된 데이터를 실험자와 activity에 따라 분류하고

2번... 읽기

그리고 3번 읽기. 그 다음은 4번 읽기. 5번읽기. 6번읽기. 과정을 진행하게 됩니다. 

다음은 각 과정에 대해서 자세히 알아보겠습니다.

먼저 각 실험자가 수행한 실험에서 측정된 가속도와 각속도 신호를 6가지 acitivity에 따라 분류합니다.

그 다음 머신러닝 모델에 학습시키고 검증하기 위해 70퍼센트의 트레인 데이터와 30퍼센트의 테스트 데이터로 데이터를 나눕니다.

다음은 신호 가공과정인데 크게 2가지 필터 방법을 사용했습니다.

첫번째가 noise를 제거하기 위한 noise filering, 다른 하나가 중력과 노이즈를 제거하기 위한 gravity filtering 방식입니다.

noise filtering은 다음과 같이 median filter를 사용해서 수행했고 4개 데이터가 샘플링 됐다고 하면

third order median filter는 3개 데이터에 대해 중앙값을 취해서 4개의 데이터를 재구성 하게 됩니다.

주로 이상치 제거를 하는데 쓰이고 이 이상치는 background noise라고 불리는 갑작스러운 움직임에 의한 ups and downs를 나타냅니다.

1차로 noise filter를 하고 2차로 low pass butterworth filter를 거칩니다.

이 필터는 간단하게 설명하면 낮은 주파수 값을 통과시키고 높은 주파수를 감쇠하는 필터인데 

이 실험에서는 20hz 고주파수를 감쇠하고 0.3hz의 저주파수를 감쇠했습니다.

그 이유는 참고문헌에 나온 내용인데 사람의 몸이 움직일때 15hz 미만의 에너지가 포함된다고 합니다. 

그래서 15hz에서 조금 여유를 줘서 20hz이상의 주파수를 noise 처리했고 

0.3hz도 마찬가지로 참고문헌에 나온 내용인데 중력이 대략 0.3hz 이하의 저 주파수 신호로 포착된다고 합니다.

그래서 모션에 대해서 중력만을 제거한 신호를 추출하기 위해 0.3hz 이하의 주파수가 제거가 됩니다.


이 과정을 표현한 것이 다음 그림입니다.

미디언 필터를 이용해서 노이즈 처리를 해주고 FFT 과정을 거칩니다.

뒤에 설명하겠지만 이 과정을 통해서 시간에 대한 신호를 주파수에 대해 나타낼 수 있게 됩니다.

이 그림이 50hz의 일정 샘플링으로 추출하여 주파수에 대한 신호함수로 변환한 것입니다.

그래서 이 total 가속도의 주파수 데이터를 중력가속도를 제거한 바디에 대한 주파수와 중력가속도 부분으로 나눠서

역퓨리에 변환을 이용해서 중력가속도를 제거한 바디의 시간에 대한 신호함수를 구할 수 있게 됩니다.

그림을 보시면 범위가 -25에서 25인데 마이너스 헤르츠는 물리적으로는 존재하지 않는 값이고 퓨리에 트랜스폼의 이론 전개 과정에서

수학적으로 복소평면을 사용하게 되는데 그 때 복소평면상에서 한 주기를 돌때 시계방향으로 도냐 반시계 방향으로 도냐에 따라

-헤르츠와 +헤르츠로 나타나게 되는 것이고 실제로는 25hz안의 주파수 범위에서 값이 구해집니다. 이게 왜 50hz의 절반인

25hz가 되는지는 뒤에서 설명하도록 하겠습니다.

그래서 20~25hz에 해당하는 주파수가 noise로 제거되고, 0.3hz에 해당하는 주파수가 중력가속도로 제거되게 됩니다.

실제로 이 과정에서 추출된 0.3hz에 해당하는 데이터를 계산해보니까 평균적으로 중력가속도를 나타냄을 확인할 수 있었다고 합니다.


다음은 feature selection 과정입니다.

결국에는 퓨리에 트랜스폼이라는 것이 time domain 영역의 함수를 frequency domain 영역의 함수로 바꾸는 것인데

이론적으로는 이 함수가 시간에 대한 연속함수인데 실제 세계에서는 DFT라는 과정을 통해서 일정 샘플링 주파수를 통해

이산 주파수 함수로 변환하게 됩니다. FFT는 이 DFT를 컴퓨터를 이용해서 빠르게 계산하는 알고리즘이라고 보시면 됩니다.

그래서 전의 FFT과정을 통해서 body에 해당하는 피쳐만 따로 뽑을 수 있었고 그 피쳐에 약간 수학계산을 통해서

가가속도나 벡터량의 크기 등등 같은 피쳐를 생성합니다. 그리고 FFT과정 중간에서 나온 frequency domain data도 다음과 같이

약간의 수학계산을 거치고 피쳐를 생성하게 됩니다.

그리고 이 셀렉션된 피쳐에 해당하는 데이터들은 다음과 같이 윈도잉이라는 과정을 거칩니다.

이 window 간격을 2.56초 즉 50hz하에서 128데이터 포인트가 포함되도록 구성하고 50퍼 오버랩을 시킵니다.

오버랩은 저번에 한석님께서 말씀해 주셨다시피 데이터의 누락을 방지하고 연속성을 유지하기 위해 사용됩니다.

제가 찾아보니까 오버랩을 안하고 같은주제인데 데이터 전처리 과정의 시간을 줄이는 참고문헌도 보았습니다. 

그리고 50퍼 말고 50퍼보다 적게나 많게 설정해서 검증과정을 거치는데 오버랩을 안해도 큰 문제가 없었다식의 내용이었습니다.

그래서 오버랩이 큰 상관이 없다라는 내용이었고 여기서는 데이터에 주어졌으니까 오버랩 내용을 포함시켰습니다.

그리고 처음에도 말했다시피 50hz로 샘플링했다고 했는데 이게 나이퀴스트 조건에 따라 정해진 샘플링 주파수입니다.

나이퀴스트 criterion이라는게 어떤 샘플링 주기 f에서 샘플링 될 때 f/2 보다 적은 주파수에 대해서만

안정적인 신호정보를 구할 수 있다는 것이 나이퀴스트 조건입니다. 그래서 아까 그림에서 25hz이 나온 것이고,

아까 signal processing에서 인간의 움직임에 의한 에너지가 15hz정도 나타낸다 했으니까 대략 플러스 10해서 25hz로 잡고

그 2배의 값인 50hz를 샘플링 주파수로 설정한 것 같습니다.

그래서 이 조건을 만족시켜야 하는 이유가 안지키면 다음과 같이 aliasing문제가 생기기 때문입니다. (설명)

제대로 샘플링 되면 다음과 같이 신호 모양이 나오는데 주파수가 커버리면 밑의 그림과 같이 신호 모양에 왜곡이 생깁니다.

그리고 2.56초 단위로 한 이유는 FFT가 2의 거듭제곱일때 효율적으로 실행되는데

FFT 자체가 컴퓨터 알고리즘으로 n^2의 시간이 걸리는 문제를 nlogn의 시간이 걸리도록 계산하는 알고리즘입니다.

이 logn의 밑이 2여서 2의 거듭제곱일때 효율적으로 실행되는 것이고 이것도 꼭 2.56초 일 필요는 없고 1.28도 될 것 같습니다.

다만 데이터 양이 줄어든다 이런 점만 존재할 것 같습니다. 그래서 지금까지 이 실험에서 진행한 windowing 과정에 대해 설명하였습니다.

다음은 데이터 전처리과정의 마지막인 feature generation 과정입니다. windowing까지 거친 피쳐들에 대해

각 window의 단위 즉 128 포인트마다 이 표와 같은 통계적 특징을 계산하여 구합니다. 

그래서 총 561개의 feature가 각 window에 대해 생성되고 이 데이터는 X train data와 x test data에 저장됩니다.

지금까지 이 실험에서 진행한 데이터 전처리 과정에 대해 소개했고

다음은 인터넷에서 다운받은 이 과정을 거친 최종적인 데이터 셋의 구조와 병합에 대해 설명하도록 하겠습니다.















































  



 
